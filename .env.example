# ══════════════════════════════════════════════════════════════════════
# Bank→YNAB v4.0 — Environment Variables
# ══════════════════════════════════════════════════════════════════════
#
# Copy this file to .env and fill in your actual values:
#   cp .env.example .env
#
# NEVER commit .env to version control!
# ══════════════════════════════════════════════════════════════════════

# ── Google AI (Required) ─────────────────────────────────────────────
# Get your API key from: https://aistudio.google.com/apikey
GOOGLE_API_KEY=your-google-api-key-here

# GCP project ID (used for OpenTelemetry, Pub/Sub, and ADK runtime)
GOOGLE_CLOUD_PROJECT=your-gcp-project-id

# ── Event Bus Backend ────────────────────────────────────────────────
# Controls the EventBus implementation (12-Factor config-driven):
#   memory  — In-memory bus (default). Zero deps, ideal for dev/test.
#   pubsub  — Google Cloud Pub/Sub. Durable, cross-instance fanout. For production.
# EVENTBUS_BACKEND — "memory" (default) | "pubsub" (production)
# Auto: unset=memory. Set via --set-env-vars at Cloud Run deploy.
# Local E2E: EVENTBUS_BACKEND=pubsub python scripts/run_e2e_bank_to_ynab.py

# ── Session Backend ──────────────────────────────────────────────────
# Controls the SessionService implementation (12-Factor config-driven):
#   memory    — In-memory sessions (default). Zero deps, ideal for dev/test.
#   firestore — Google Cloud Firestore. Durable, serverless. For production.
# SESSION_BACKEND — "memory" (default) | "firestore" (production)
# Auto: unset=memory. Set via --set-env-vars at Cloud Run deploy.

# ── Memory Backend ───────────────────────────────────────────────────
# Controls the MemoryService implementation (12-Factor config-driven):
#   memory    — ADK InMemoryMemoryService (default). Keyword matching, zero deps.
#   firestore — FirestoreVectorMemoryService. Durable, semantic search via Gemini embeddings.
#   vertexai  — Vertex AI Memory Bank. Persistent, semantic search (managed).
# MEMORY_BACKEND — "memory" (default) | "firestore" (production) | "vertexai"
# For firestore: optional tuning via MEMORY_EMBEDDING_* vars below.
# For vertexai: set MEMORY_AGENT_ENGINE_ID to your Vertex AI Agent Engine ID.
# Auto: unset=memory. Set via --set-env-vars at Cloud Run deploy.
#
# Firestore Vector Memory tuning (only used when MEMORY_BACKEND=firestore):
# MEMORY_EMBEDDING_MODEL=gemini-embedding-001          — Embedding model
# MEMORY_EMBEDDING_DIMENSIONALITY=768                  — Vector dimensions (Google recommended)
# MEMORY_SEARCH_LIMIT=20                               — Max results from search_memory()

# ── Artifact Backend ─────────────────────────────────────────────────
# Controls the ArtifactService implementation (12-Factor config-driven):
#   memory  — In-memory artifacts (default). Zero deps, ideal for dev/test.
#   gcs     — Google Cloud Storage. Versioned, durable. For production.
# ARTIFACT_BACKEND — "memory" (default) | "gcs" (production)
# For gcs: set ARTIFACT_GCS_BUCKET to your GCS bucket name.
# Auto: unset=memory. Set via --set-env-vars at Cloud Run deploy.

# ── Run Log Backend ──────────────────────────────────────────────────
# Controls the RunLogService implementation (12-Factor config-driven):
#   memory    — In-memory run log (default). Zero deps, ideal for dev/test.
#   firestore — Google Cloud Firestore. Durable, survives scale-to-zero. For production.
# RUN_LOG_BACKEND — "memory" (default) | "firestore" (production)
# Auto: unset=memory. Set via --set-env-vars at Cloud Run deploy.

# ── Model Rate Limiting ──────────────────────────────────────────────
# Proactive QPM (queries-per-minute) limiter per model (Layer 2).
# Uses token-bucket with back-pressure (sleeps instead of rejecting).
# Layer 1 (ADK-native HttpRetryOptions) is always-on regardless.
# MODEL_RATE_LIMIT_QPM — 0 (default, disabled) | 1500 (recommended for production)
# Production: gcloud run deploy --set-env-vars MODEL_RATE_LIMIT_QPM=1500

# ── Context Caching (Per-Agent Opt-In) ───────────────────────────────
# Gemini context caching caches system instructions + tool schemas server-side.
# Caching is per-agent: set cache_context=True in create_platform_agent().
# These env vars configure the cache parameters when an agent opts in.
# CONTEXT_CACHE_MIN_TOKENS=2048      — Min tokens to trigger caching
# CONTEXT_CACHE_TTL_SECONDS=1800     — Cache TTL (30 min default)
# CONTEXT_CACHE_INTERVALS=10         — Max uses before refresh

# ── Context Window Compression ───────────────────────────────────────
# ADK-native SlidingWindow compression for long-running conversations.
# When token count exceeds trigger, older history is compressed to target.
# Applied via RunConfig in ADKRunner — affects all agents uniformly.
# CONTEXT_COMPRESSION_TRIGGER_TOKENS=100000  — Start compression (~78% of 128k)
# CONTEXT_COMPRESSION_TARGET_TOKENS=80000    — Compress to (~62% of 128k)
# Set both to 0 to disable compression entirely.

# Model to use for all agents (default: gemini-3-flash-preview)
# MODEL_NAME=gemini-3-flash-preview

# ── YNAB (Required) ──────────────────────────────────────────────────
# Get your personal access token from: https://app.ynab.com/settings/developer
YNAB_ACCESS_TOKEN=your-ynab-access-token-here

# Optional: pre-set budget and account IDs (auto-detected by agents if empty)
# YNAB_BUDGET_ID=
# YNAB_ACCOUNT_ID=

# ── Ingestion Mode (Required for v4.2+) ──────────────────────────────
# Controls how the app receives emails:
#   api     — Only HTTP endpoints, no Gmail integration (default)
#   push    — Gmail push notifications via Pub/Sub (RECOMMENDED for production)
#   polling — HTTP endpoints + background Gmail polling (dev/local only)
#   hybrid  — Push + polling fallback with automatic deduplication
INGESTION_MODE=api

# ── GCP Pub/Sub (Required for push/hybrid modes) ────────────────────
# Format: projects/{GCP_PROJECT_ID}/topics/{TOPIC_NAME}
# Create the topic in GCP Console and grant publish access to:
#   gmail-api-push@system.gserviceaccount.com
# GCP_PUBSUB_TOPIC=projects/my-project/topics/gmail-notifications

# Label IDs to filter push notifications (comma-separated)
# GMAIL_PUSH_LABEL_IDS=["INBOX"]

# ── Gmail Settings (Optional) ───────────────────────────────────────

# Polling interval in seconds (only used with polling/hybrid modes)
# POLL_INTERVAL_SECONDS=60

# Auto-create transactions in YNAB when processing via Gmail (push or polling)
# GMAIL_AUTO_CREATE=true

# Mark emails as read after successful processing
# GMAIL_MARK_AS_READ=false

# ── Guardrails (Optional) ────────────────────────────────────────────
# Maximum transaction amount (COP) before flagging for review
# MAX_TRANSACTION_AMOUNT=50000000

# Window in minutes to check for duplicate transactions
# DUPLICATE_WINDOW_MINUTES=5

# ── OpenTelemetry (Optional — Cloud Run auto-configures this) ────────
# OTLP exporter endpoint for traces
# OTEL_EXPORTER_OTLP_ENDPOINT=http://localhost:4317

# ── Runtime (Optional) ───────────────────────────────────────────────
# PORT=8080

# ── Airtable (Optional) ──────────────────────────────────────────────
# Get your personal access token from: https://airtable.com/create/tokens
# AIRTABLE_PERSONAL_ACCESS_TOKEN=your-airtable-token-here

API_KEY_SECRET=

# ── Home Assistant (Optional) ────────────────────────────────────────
# Base URL of your Home Assistant instance (MCP Streamable HTTP at /api/mcp)
# HASS_URL=https://home-assistant.example.com
# Long-lived access token (Profile → Long-Lived Access Tokens)
# HASS_TOKEN=your-long-lived-access-token
# Cloudflare Tunnel — Service Token (optional, only if HA is behind CF Tunnel)
# CF_ACCESS_CLIENT_ID=your-client-id.access
# CF_ACCESS_CLIENT_SECRET=your-client-secret

# ── CORS (Optional — disabled by default for headless API) ──────────
# Comma-separated list of allowed browser origins.
# Leave empty or unset for headless API mode (no CORS headers).
# Example: API_CORS_ORIGINS=https://admin.example.com,http://localhost:3000
# API_CORS_ORIGINS=

# ── Polymarket BTC Trader (Optional) ─────────────────────────────────
# Polygon wallet private key (required for live trading, not needed for paper trading)
# POLYMARKET_PRIVATE_KEY=
# Polymarket proxy wallet address (your funder address)
# POLYMARKET_PROXY_WALLET=
# Risk controls (defaults are conservative)
# POLYMARKET_MAX_TRADE_USD=20
# POLYMARKET_DAILY_LOSS_CAP=100
